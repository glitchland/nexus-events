//! Type-safe registry system for event handlers
//! 
//! This module provides a thread-safe registry for storing and retrieving
//! type-specific event handlers. It's used internally by the event system
//! to track handlers registered via the `#[event_handler]` attribute.

use std::any::TypeId;
use std::collections::HashMap;
use std::sync::RwLock;
use once_cell::sync::OnceCell;

use super::handler_info::EventHandlerInfo;

/// Thread-safe registry of event handlers for a specific component type
///
/// The registry stores all event handlers for a particular component type.
/// It's populated at compile time by the `#[event_handler]` attribute macro
/// and used at runtime when registering event handlers.
///
/// # Type Parameters
///
/// * `T` - The component type these handlers belong to
///
/// # Implementation Details
///
/// This uses a global static registry per component type, protected by a RwLock
/// for thread safety. Handlers are registered once when the program starts and then
/// read at runtime when components are activated.
#[doc(hidden)]
pub struct EventHandlerRegistry<T: 'static> {
    handlers: Vec<&'static EventHandlerInfo<T>>,
}

impl<T: 'static> Default for EventHandlerRegistry<T> {
    fn default() -> Self {
        Self {
            handlers: Vec::new(),
        }
    }
}

// Global registry system that avoids the generic parameter issue
struct RegistrySystem {
    // Store references to registries directly with TypeId as key
    // The value is an erased pointer that will be cast back to the correct type
    registries: HashMap<TypeId, *const ()>,
}

// Mark the struct as Send + Sync since we're using raw pointers
// This is safe because we only store static references
unsafe impl Send for RegistrySystem {}
unsafe impl Sync for RegistrySystem {}

impl RegistrySystem {
    fn get_or_create_registry<T: 'static>() -> &'static RwLock<EventHandlerRegistry<T>> {
        // Create a thread-safe singleton for all registries
        static INSTANCE: OnceCell<RwLock<RegistrySystem>> = OnceCell::new();
        
        let system = INSTANCE.get_or_init(|| {
            RwLock::new(RegistrySystem {
                registries: HashMap::new()
            })
        });
        
        // Get type ID for the requested registry type
        let type_id = TypeId::of::<T>();
        
        // First try to get an existing registry
        {
            let system_guard = system.read().unwrap();
            if let Some(&ptr) = system_guard.registries.get(&type_id) {
                // Cast the raw pointer back to the correct type
                // Safety: We only store pointers of the correct type for each TypeId
                let registry = unsafe { &*(ptr as *const RwLock<EventHandlerRegistry<T>>) };
                return registry;
            }
        }
        
        // Registry doesn't exist yet, create a new one
        let new_registry = Box::new(RwLock::new(EventHandlerRegistry::<T>::default()));
        let static_registry = Box::leak(new_registry);
        
        // Store a raw pointer to the registry
        let mut system_guard = system.write().unwrap();
        system_guard.registries.insert(type_id, static_registry as *const _ as *const ());
        
        static_registry
    }
}

impl<T: 'static> EventHandlerRegistry<T> {
    /// Gets the global registry instance for a specific component type
    ///
    /// This method provides access to the singleton registry for the type `T`.
    /// It's initialized on first access using thread-safe lazy initialization.
    ///
    /// # Returns
    ///
    /// A static reference to the thread-safe registry
    ///
    /// # Thread Safety
    ///
    /// This implementation ensures that initialization happens exactly once,
    /// even in multi-threaded contexts.
    pub fn get_instance() -> &'static RwLock<EventHandlerRegistry<T>> {
        RegistrySystem::get_or_create_registry::<T>()
    }
    
    /// Registers a new event handler with this registry
    ///
    /// This method is called by the static initialization code generated by the
    /// `#[event_handler]` attribute. It adds the handler information to the registry
    /// if it hasn't already been registered.
    ///
    /// # Arguments
    ///
    /// * `info` - Static reference to the handler information
    pub fn register_handler(info: &'static EventHandlerInfo<T>) {
        if let Ok(mut registry) = Self::get_instance().write() {
            if !registry.handlers.iter().any(|h| h.name == info.name) {
                registry.handlers.push(info);
            }
        }
    }
    
    /// Retrieves all registered handlers for this component type
    ///
    /// This method is called when a component is activated to discover all
    /// the event handlers that should be registered with the event bus.
    ///
    /// # Returns
    ///
    /// A vector of static references to handler information structs
    ///
    /// # Thread Safety
    ///
    /// Handlers are returned as a cloned vector to avoid holding the lock
    /// during handler registration.
    pub fn get_all_handlers() -> Vec<&'static EventHandlerInfo<T>> {
        if let Ok(registry) = Self::get_instance().read() {
            registry.handlers.clone()
        } else {
            Vec::new()
        }
    }
}